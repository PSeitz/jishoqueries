'use strict';

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

var chalk = require('chalk');

var _require = require('ramda');

var __ = _require.__;
var add = _require.add;
var allPass = _require.allPass;
var bind = _require.bind;
var complement = _require.complement;
var concat = _require.concat;
var cond = _require.cond;
var equals = _require.equals;
var init = _require.init;
var isNil = _require.isNil;
var last = _require.last;
var pipe = _require.pipe;
var propSatisfies = _require.propSatisfies;
var T = _require.T;
var type = _require.type;

var prettyHrtime = require('pretty-hrtime');

var COLORS = ['green', 'yellow', 'blue', 'magenta', 'cyan', 'white'];
var rotate = function rotate(xs) {
  var i = 0;
  return function () {
    return xs[i++ % xs.length];
  };
};

var nextColor = rotate(COLORS);
var getArgs = function getArgs(label, val) {
  return typeof label !== 'string' ? [label, null] : [val, label];
};

var isFunction = pipe(type, equals('Function'));
var hasThenFn = allPass([complement(isNil), propSatisfies(isFunction, 'then')]);
var writeStderr = bind(process.stderr.write, process.stderr);
var println = pipe(add(__, '\n'), writeStderr);

var printDuration = function printDuration(start, color, label) {
  var end = process.hrtime(start);
  var pre = label ? chalk.bold(label) + ' took ' : '';
  var dur = prettyHrtime(end);
  println(color(pre + dur));
};

//    taim :: label?, Function -> Function
//    taim :: label?, Promise  -> Promise
var taim = function taim() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var color = chalk[nextColor()];

  var _getArgs = getArgs.apply(undefined, args);

  var _getArgs2 = _slicedToArray(_getArgs, 2);

  var val = _getArgs2[0];
  var label = _getArgs2[1];

  return cond([[hasThenFn, function (val) {
    var start = process.hrtime();
    val.then(function () {
      printDuration(start, color, label);
    });

    return val;
  }], [isFunction, function (val) {
    return function () {
      var start = process.hrtime();
      var res = val.apply(undefined, arguments);
      var fn = function fn() {
        return printDuration(start, color, label);
      };

      if (res && hasThenFn(res)) res.then(fn);else fn();

      return res;
    };
  }], [T, function (val) {
    println('taim error: input should be a function or thenable, instead got a ' + type(val));
    return val;
  }]])(val);
};

//    taimCb :: label?, Function -> Function
var taimCb = function taimCb() {
  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  var color = chalk[nextColor()];

  var _getArgs3 = getArgs.apply(undefined, args);

  var _getArgs32 = _slicedToArray(_getArgs3, 2);

  var val = _getArgs32[0];
  var label = _getArgs32[1];

  return cond([[isFunction, function (val) {
    return function () {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      var origCb = last(args);
      var start = process.hrtime();
      val.apply(undefined, _toConsumableArray(concat(init(args), [function () {
        printDuration(start, color, label);
        origCb.apply(undefined, arguments);
      }])));
    };
  }], [T, function (val) {
    println('taim error: input should be a function, instead got a ' + type(val));
    return val;
  }]])(val);
};

module.exports = taim;
module.exports.cb = taimCb;

